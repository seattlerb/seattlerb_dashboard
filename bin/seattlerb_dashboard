#!/usr/bin/env ruby -ws

require 'rubygems'
require 'tagz'
require 'seattlerb_projects'

old_comma, $, = $,, ', '

def check_project project
  Dir.chdir project do
    ver = Dir["[0-9]*"].sort_by { |name| name.split(/\./).map { |n| n.to_i } }
    if ver.empty? then
      nil
    else
      ! system "diff -rq #{ver.last} dev | grep -q differ$"
    end
  end
end

total_passed = total_failed = 0

projs    = SeattlerbProjects.new.projects.flatten
status   = Hash.new { |h,k| h[k] = Hash.new { |h2,k2| h2[k2] = "n/a" } }
versions = Dir.chdir(File.expand_path("~/.multiruby/install")) { Dir["*"].sort }
naming   = versions.map { |n| n.sub(/rubinius/, 'xx') }
naming   = Hash[*versions.zip(naming).flatten]

raise "non-unique name: #{naming.inspect}" if
  naming.values.uniq.size != naming.size
raise "unknown version" if naming.keys.sort != versions.sort

color = {
  "failed" => "#F99",
  "passed" => "#9F9",
  "n/a" => "#ccc",
}

puts "Project: #{versions.flatten}"

dir = ARGV.shift || File.expand_path("~/Sites/dashboard")

Dir.mkdir dir unless File.exist? dir

format = "%-#{projs.map { |s| s.size }.max}s : %s : %s"

projs.each do |proj|
  next if proj =~ /rubyforge/ # HACK

  proj_dir = case proj
        when /rubyforge/ then
          File.expand_path("~/Work/svn/codeforpeople/rubyforge/trunk")
        else
          "#{proj}/dev"
        end

  ENV['VERSIONS'] = versions.join(':')

  run = Dir.chdir proj_dir do
    `rake -q clean multi 2>&1`
  end

  File.open "#{dir}/#{proj}.txt", 'w' do |f|
    f.write run
  end

  passed = run[/^Passed: .*/]
  failed = run[/^Failed: .*/]

  passed.split(/[:,] /)[1..-1].each do |version|
    status[proj][version] = true
    total_passed += 1
  end unless passed.nil?

  failed.split(/[:,] /)[1..-1].each do |version|
    status[proj][version] = false
    total_failed += 1
  end unless failed.nil?

  results = status[proj]

  row = versions.map { |version| results[version] ? "T" : "F" }

  up_to_date = check_project(proj)

  release_status = {
    nil   => "never released",
    true  => "up-to-date",
    false => "needs release",
  }[up_to_date]

  puts format % [proj, row, release_status]
end

puts
puts "passed: #{total_passed} failed: #{total_failed}"

$, = old_comma

File.open "#{dir}/index.html", 'w' do |f|
  f.puts Tagz {
    tagz.puts %(<!D\OCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN">)
    html_ {
      head_ {
        title_ { "Project Status Report" }
        style_(:type=>"text/css") {
          tagz << "*      { padding: 0; margin: 0; }"
          tagz << "table  { margin: 0 auto; padding: 0; border-spacing: 0; }"
          tagz << "th, td { text-align: right; font-size:0.7em;}"
          tagz << "th     { font-weight: normal; }"
        }
      }
      body_ {
        table_ {
          tr_ {
            th_ { tagz.concat "&nbsp;" }
            versions.each do |v|
              th_ { naming[v] }
            end
          }
          projs.each do |proj|
            results = status[proj]
            tr_ {
              th_ {
                a_(proj, :href => "#{proj}.txt")
              }
              versions.each do |version|
                r = results[version] || "failed"
                r = "passed" if r == true
                td_("", :style => "background: #{color[r]}")
              end
            }
          end

          naming.sort.each do |orig, short|
            tr_ {
              th_(short)
              td_(orig, :colspan => 5)
            }
          end

          tr_ {
            td_(Time.now.strftime("%Y-%m-%d %H:%M"), :colspan => 6)
          }
        }
      }
    }
  }
end
