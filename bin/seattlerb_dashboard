#!/usr/bin/env ruby -ws

$v ||= false
$f ||= false
$r ||= false

require 'rubygems'
require 'yaml'
require 'seattlerb_projects'

old_comma, $, = $,, ', '

total_passed = total_failed = 0

seattlerb = SeattlerbProjects.new
projs     = seattlerb.projects.flatten
status    = Hash.new { |h,k| h[k] = Hash.new { |h2,k2| h2[k2] = "n/a" } }
versions  = Dir.chdir(File.expand_path("~/.multiruby/install")) { Dir["*"].sort}
flog = {}
flay = {}

code = {
  "n/a" => "o",
  nil   => "o",
  true  => "T",
  false => "F",
}

release = {
  "n/a" => "o",
  nil   => "o",
  true  => "Y",
  false => "N",
}

seattlerb.chdir_src

up_to_date = {}

puts "Project: #{versions.flatten}"

dir = ARGV.shift || File.expand_path("~/Sites/dashboard")

Dir.mkdir dir unless File.exist? dir

format = "%-#{projs.map { |s| s.size }.max}s : %s : %s : %8.2f : %8.2f"

$cache_stale = false
def cache_against_dir_mtimes cache_path, dir
  next unless File.directory? dir
  Dir.chdir dir do
    cache_mtime = File.mtime(cache_path) rescue Time.at(0)
    dir_mtime = Dir["**"].map { |f| File.mtime f if File.exist? f }.compact.max

    if $cache_stale || cache_mtime < dir_mtime then
      $cache_stale = !$f
      data = yield

      File.open cache_path, 'w' do |f|
        YAML.dump data, f
      end

      data
    else
      YAML.load_file cache_path
    end
  end
end

projs.each do |proj|
  warn proj if $v
  next if proj =~ /^rubyforge/ # HACK

  proj_dir = case proj
        when /^rubyforge/ then
          File.expand_path("~/Work/svn/codeforpeople/rubyforge/trunk")
        else
          "#{proj}/dev"
        end

  next unless File.directory? proj_dir

  ENV['VERSIONS'] = versions.join(':')

  data = cache_against_dir_mtimes "#{dir}/#{proj}.yaml", proj_dir do
    dirs = Dir["{lib,test}"].join(" ")
    dirs = "." if dirs.empty?
    {
      :test => `rake -q clean multi 2>&1`,
      :flog => `flog -s #{dirs} | head -1`[/\d+(\.\d+)?/].to_f,
      :flay => `flay -s #{dirs} | head -1`[/\d+(\.\d+)?/].to_f,
    }
  end

  run = data[:test]
  passed = run[/^Passed: .*/]
  failed = run[/^Failed: .*/]

  passed.split(/[:,] /)[1..-1].each do |version|
    status[proj][version] = true
    total_passed += 1
  end unless passed.nil?

  failed.split(/[:,] /)[1..-1].each do |version|
    status[proj][version] = false
    total_failed += 1
  end unless failed.nil?

  results = status[proj]

  row = versions.map { |version| code[results[version]] }

  up_to_date[proj] = seattlerb.check_project(proj)
  results[:flog] = data[:flog] == 0 ? nil : data[:flog]
  results[:flay] = data[:flay] == 0 ? nil : data[:flay]

  puts format % [proj, release[up_to_date[proj]], row, data[:flog], data[:flay]]
end

css = <<-EOM
*         { padding: 0; margin: 0; }
table     { margin: 1em auto; padding: 0; border-spacing: 0; }
th, td    { text-align: right; font-size:0.7em; width: 1em;}
th        { font-weight: normal; }
p         { text-align: center; }
tr#top th { vertical-align: bottom; text-align: left; height: 7em; }
.rot      { -webkit-transform: rotate(-90deg); -moz-transform: rotate(-90deg);
            -webkit-transform-origin: bottom;  -moz-transform-origin: bottom;
            position:absolute;
            margin-top: -6em;
            margin-left: -4em;
            width: 10em;
            line-height: 0em; }
EOM

puts
puts "passed: #{total_passed} failed: #{total_failed}"

$, = old_comma

exit if $r

color = {
  "passed" => "#9F9",
  true     => "#9F9",
  "failed" => "#F99",
  false    => "#66F",
  "n/a"    => "#ccc",
  nil      => "#ccc",
}

require 'erector'
include Erector::Mixin

File.open "#{dir}/index.html", 'w' do |f|
  f.puts erector(:prettyprint => true) {
    raw %(<!D\OCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN">)
    html {
      head {
        title { "Project Status Report #{Time.now.strftime("%Y-%m-%d %H:%M")}"}
        style raw(css), :type=>"text/css"
      }
      body {
        table {
          tr(:id => :top) {
            td {
              table(:style => "border: 1px solid black; padding: 2px;") {
                tr { td "Packages:"; td projs.size }
                tr { td "Releases:"; td Dir["*/[0-9]*"].size }
                tr { td "Commits:";  td `p4 counter change` }
              }
            }
            th nbsp
            th { div "released\?", :class => :rot }
            th nbsp
            versions.each do |v|
              th { div v, :class => :rot }
            end
            th nbsp
            th { div "flog", :class => :rot }
            th nbsp
            th { div "flay", :class => :rot }
          }
          projs.each do |proj|
            results = status[proj]
            tr {
              th {
                a(proj, :href => "#{proj}.yaml")
              }

              td nbsp

              td("", :style => "background: #{color[up_to_date[proj]]}")

              td nbsp

              versions.each do |version|
                r = results[version] || "failed"
                r = "passed" if r == true
                td("", :style => "background: #{color[r]}")
              end

              td nbsp
              td { text "%.2f" % results[:flog] if results[:flog] }
              td nbsp
              td { text "%.2f" % results[:flay] if results[:flay] }
            }
          end
        }
      }
    }
  }
end
